<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Rift AI – Quantum AGI Assistant</title>
  <meta name="description" content="Rift AI – Quantum AGI with Multi-Agent Architecture by 0penAGI." />
  <meta name="keywords" content="Rift AI, quantum AGI, multi-agent, 0penAGI" />
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <!-- React + Lucide Icons (CDN) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/lucide-react@latest/dist/umd/lucide-react.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #eee;
      line-height: 1.1;
      overflow-x: hidden;
      background-color: transparent;
      scroll-behavior: smooth;
    }

    #vanta-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      touch-action: none;
    }

    body {
      padding: 16px;
    }

    .container {
      max-width: 666px;
      margin: 0 auto;
    }

    .glass {
      background: rgba(255, 255, 255, 0.03);
      border: 0.7px solid rgba(255, 255, 255, 0.1);
      border-radius: 28px;
      backdrop-filter: blur(3.14px) saturate(188%);
      -webkit-backdrop-filter: blur(3px) saturate(188%);
      box-shadow: 
        0 2px 11px rgba(0, 0, 0, 0.1),
        inset 0 0 11px rgba(255, 255, 255, 0.03);
      padding: 9px;
      margin-bottom: 15px;
      opacity: 0;
      transform: translateY(40px) scale(0.93);
      transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1), transform 0.8s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.3s ease;
      will-change: transform, opacity;
    }

    @supports not (backdrop-filter: blur(3.14px)) {
      .glass { background: rgba(255, 255, 255, 0.15); }
    }

    .glass.visible {
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    .glass:hover {
      transform: translateY(-2px) scale(1.02);
      box-shadow: 
        0 4px 20px rgba(0, 0, 0, 0.15),
        inset 0 0 12px rgba(255, 255, 255, 0.1);
    }

    .header h1 {
      font-size: 0.77rem;
      font-weight: 800;
      letter-spacing: 3px;
      color: #fff;
      text-align: center;
      opacity: 0;
      animation: fadeIn 1.314s ease-out forwards;
    }

    .header p {
      font-size: 0.55rem;
      color: #ccc;
      text-align: center;
      margin-top: 11px;
      opacity: 0;
      animation: fadeIn 1.314s ease-out 0.2628s forwards;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .cards { display: flex; flex-direction: column; gap: 11px; text-align: center; }
    .card-title { font-size: 0.68rem; font-weight: 700; text-transform: uppercase; margin-bottom: 11px; color: #fff; }
    .card-subtitle { font-size: 0.55rem; color: #bbb; margin-bottom: 11px; }
    .card-features { list-style: none; padding-left: 0; }
    .card-features li { margin-bottom: 8px; padding-left: 11px; font-size: 0.66rem; }

    .philosophy { font-size: 0.78rem; color: #eaeaea; }
    .philosophy strong { color: #fff; }

    .contact { text-align: center; color: #fff; }
    .contact a { color: #9ad0ff; text-decoration: none; font-size: 0.77rem; }
    .contact a:hover { text-decoration: underline; }

    .carousel-container { position: relative; width: 100%; overflow: hidden; margin-bottom: 11px; }
    .carousel { display: flex; overflow-x: auto; scroll-behavior: smooth; gap: 11px; padding: 8px 0; scrollbar-width: none; }
    .carousel::-webkit-scrollbar { display: none; }
    .carousel-item {
      flex: 0 0 auto; background: rgba(255,255,255,0.1); border: 0.7px solid rgba(255,255,255,0.1);
      border-radius: 25px; padding: 7px 7px; backdrop-filter: blur(4px) saturate(150%);
      display: flex; justify-content: center; align-items: center; transition: all 0.3s ease;
    }
    .carousel-item:hover { background: rgba(255,255,255,0.2); transform: scale(1.05); box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
    .carousel-item a { color: #9ad0ff; font-size: 0.75rem; font-weight: 600; text-decoration: none; padding: 0 12px; }

    @media (max-width: 600px) {
      .container { padding: 0 7.9px; }
      .header h1 { font-size: 0.77rem; }
      .card-title { font-size: 0.88rem; }
      .glass { padding: 9px; margin-bottom: 12px; }
      .carousel-item { padding: 6px 12px; }
      .carousel-item a { font-size: 0.88rem; }
    }

    @media (prefers-reduced-motion: reduce) {
      .glass, .glass.visible, .glass:hover { transition: none; transform: none !important; animation: none; }
    }

    .image-gallery { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 15px; }
    .image-gallery img { max-width: 100%; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: transform 0.3s ease; }
    .image-gallery img:hover { transform: scale(1.05); }

    /* Sensory Echo Mini App Styles */
    #sensory-echo-root .echo-particle {
      position: absolute; width: 8px; height: 8px; background: white; border-radius: 50%;
      opacity: 0.3; animation: float 3s infinite ease-in-out;
    }
    @keyframes float {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      50% { transform: translateY(-20px) rotate(180deg); }
    }
  </style>
</head>
<body>
  <div id="vanta-bg"></div>

  <main class="container">
    <!-- Header -->
    <header class="glass header">
      <h1>Rift AI</h1>
      <p>Quantum AGI with Multi-Agent Architecture by 0penAGI</p>
    </header>

    <!-- Image Gallery -->
    <section class="glass">
      <div class="image-gallery">
        <!-- Placeholder images since original used custom grok-card elements -->
        <img src="https://via.placeholder.com/200?text=Image+1" alt="Placeholder Image 1">
        <img src="https://via.placeholder.com/200?text=Image+2" alt="Placeholder Image 2">
        <img src="https://via.placeholder.com/200?text=Image+3" alt="Placeholder Image 3">
      </div>
    </section>

    <!-- Feature Cards -->
    <section class="cards">
      <article class="glass">
        <h2 class="card-title">Intelligent Assistance</h2>
        <p class="card-subtitle">Your quantum-powered helper</p>
        <ul class="card-features">
          <li>Natural language interactions</li>
          <li>Multi-platform support</li>
          <li>Data analysis & reasoning</li>
          <li>Flexible & scalable</li>
        </ul>
      </article>

      <article class="glass">
        <h2 class="card-title">Multi-Modal Capabilities</h2>
        <p class="card-subtitle">Handle any input type</p>
        <ul class="card-features">
          <li>Text, voice & vision processing</li>
          <li>Document summarization</li>
          <li>Image analysis</li>
          <li>Real-time responses</li>
        </ul>
      </article>

      <article class="glass">
        <h2 class="card-title">Advanced Features</h2>
        <p class="card-subtitle">Powered by quantum inspiration</p>
        <ul class="card-features">
          <li>Self-awareness & ethics</li>
          <li>Creative generation</li>
          <li>Weather & time insights</li>
          <li>Custom agents</li>
        </ul>
      </article>

      <aside class="glass philosophy">
        <p>
          <strong>Rift AI evolves with you.</strong><br />
          From simple queries to complex tasks, experience intelligent support that adapts to your needs.<br />
          <strong>Built for the future of AI assistance.</strong>
        </p>
      </aside>
    </section>

    <!-- Contact & Carousel -->
    <section class="glass contact">
      <div class="carousel-container">
        <div class="carousel">
          <div class="carousel-item"><a href="https://github.com/0penAGI" target="_blank">GitHub</a></div>
          <div class="carousel-item"><a href="https://t.me/gptfddbot" target="_blank">Telegram Bot</a></div>
          <div class="carousel-item"><a href="https://t.me/Zeropenagi" target="_blank">0penAGI</a></div>
        </div>
      </div>
      <p><strong>Contact:</strong> Available on request</p>
      <form id="contact-form" action="mailto:thedubsty@gmail.com" method="post" enctype="text/plain">
        <input id="email-field" type="email" placeholder="your.email@example.com" required />
        <button type="submit">Send Inquiry</button>
      </form>
    </section>

    <!-- Sensory Echo Mini App -->
    <section class="glass">
      <div id="sensory-echo-root"></div>
    </section>
  </main>

  <!-- Vanta.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.net.min.js"></script>

  <script>
    // Vanta Background Initialization
    VANTA.NET({
      el: "#vanta-bg",
      mouseControls: true,
      touchControls: true,
      gyroControls: false,
      minHeight: 200.00,
      minWidth: 200.00,
      scale: .88,
      scaleMobile: .88,
      color: 0x9ad0ff,
      backgroundColor: 0x050505,
      points: 15.0,
      maxDistance: 25.0,
      spacing: 15.0
    });

    // Glass Cards Animation using Intersection Observer
    const glassCards = document.querySelectorAll('.glass');
    const observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.2 });

    glassCards.forEach((el, i) => {
      el.style.transitionDelay = `${i * 100}ms`;
      observer.observe(el);
    });

    // Contact Form Validation and Submission
    const form = document.getElementById('contact-form');
    const button = form.querySelector('button');
    const emailField = document.getElementById('email-field');
    form.addEventListener('submit', (e) => {
      e.preventDefault();
      if (!emailField.value.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)) {
        alert('Please enter a valid email address.');
        return;
      }
      button.classList.add('loading');
      setTimeout(() => {
        button.classList.remove('loading');
        alert('Opening your email client...');
        form.submit();
      }, 2000);
    });

    // Telegram Web App Integration
    let tg = window.Telegram?.WebApp;
    if (tg) {
      tg.ready();
      tg.expand();
    }

    // Sensory Echo AI Class (enhanced with more sophisticated emotion scoring)
    // Added a weighted total score and more nuanced thresholds for better prophecy variety
    class SensoryEchoAI {
      constructor() {
        this.knowledgeBase = {};
        this.emotionThresholds = { joy: 0.7, melancholy: 0.4, anxiety: 0.6, serenity: 0.8 };
        this.sensoryMemory = [];
      }

      // Analyzes user input combined with sensory data to determine emotion and generate a prophecy.
      analyzeInput(input, sensory) {
        const smellIntensity = (sensory.smell.rose * 1.2 + sensory.smell.rain * 0.8) / 2; // Weighted for positive bias
        const soundIntensity = (sensory.sound.laughter * 1.5 + sensory.sound.whisper * 0.5) / 2;
        const visualIntensity = (sensory.visual.blue * 1.0 + sensory.visual.gold * 1.2) / 2;
        const fearFactor = sensory.smell.fear * 1.5; // Amplified negative
        const silenceFactor = sensory.sound.silence * 1.2;
        const redIntensity = sensory.visual.red * 1.3;

        // Update sensory memory (limited to last 5 entries for efficiency)
        this.sensoryMemory.push({ smellIntensity, soundIntensity, visualIntensity, timestamp: Date.now() });
        if (this.sensoryMemory.length > 5) this.sensoryMemory.shift();

        // Calculate totals for positive and negative influences with weights
        const totalPositive = smellIntensity + soundIntensity + visualIntensity;
        const totalNegative = fearFactor + silenceFactor + redIntensity;

        // Determine emotion and prophecy using refactored calculation
        const { emotion, prophecyText } = this.calculateEmotion(totalPositive, totalNegative, silenceFactor, sensory.visual.blue, sensory);

        // Append custom text if input mentions 'future' or other keywords for more interactivity
        let finalProphecy = prophecyText;
        if (input.toLowerCase().includes('будущее')) {
          finalProphecy += ` Ты спросил о будущем? Эхо смеётся: "Будущее — это аромат, который ты создаёшь каждым вдохом."`;
        } else if (input.toLowerCase().includes('прошлое')) {
          finalProphecy += ` Вспоминая прошлое? Эхо шепчет: "Прошлое — эхо, которое формирует настоящее, но не определяет будущее."`;
        }

        return { prophecyText: finalProphecy, emotion };
      }

      // Refactored emotion calculation for better readability and maintainability
      calculateEmotion(totalPositive, totalNegative, silenceFactor, sensoryVisualBlue, sensory) {
        const totalScore = (totalPositive * 1.1) - (totalNegative * 1.2); // Slight positive bias in scoring
        let emotion = 'neutral';
        let prophecyText = '';

        if (totalScore > this.emotionThresholds.joy) {
          emotion = 'joyful';
          prophecyText = this.calculateJoyfulProphecy(sensory);
        } else if (totalScore < -this.emotionThresholds.anxiety) {
          emotion = 'anxious';
          prophecyText = this.calculateAnxiousProphecy(sensory.smell.fear, sensory.sound.silence);
        } else if (silenceFactor > this.emotionThresholds.serenity - 0.1 && sensoryVisualBlue > this.emotionThresholds.serenity - 0.1) {
          emotion = 'serene';
          prophecyText = this.calculateSereneProphecy(silenceFactor, sensoryVisualBlue);
        } else if (totalScore < this.emotionThresholds.melancholy) {
          emotion = 'melancholic';
          prophecyText = this.calculateMelancholicProphecy(sensory);
        }

        return { emotion, prophecyText };
      }

      // Helper functions for specific prophecy generations (enhanced with more details)
      calculateJoyfulProphecy(sensory) {
        return `Эхо вдыхает аромат роз (${(sensory.smell.rose * 100).toFixed(0)}%) и улавливает отголоски смеха (${(sensory.sound.laughter * 100).toFixed(0)}%). Оно шепчет: "Впереди — поляна возможностей, окрашенная в цвета надежды. То, что ты ищешь, найдёт тебя само. Радость переполняет потоки реальности."`;
      }

      calculateAnxiousProphecy(fearFactor, silenceFactor) {
        return `Запах страха (${(fearFactor * 100).toFixed(0)}%) смешивается с тишиной (${(silenceFactor * 100).toFixed(0)}%). Эхо предупреждает: "Тени сгущаются. Но помни — даже в темноте можно разжечь огонь. Твоё намерение определит путь сквозь бурю."`;
      }

      calculateSereneProphecy(silenceFactor, sensoryVisualBlue) {
        return `В тишине (${(silenceFactor * 100).toFixed(0)}%) и синеве (${(sensoryVisualBlue * 100).toFixed(0)}%) Эхо находит покой. Оно произносит: "Неизвестность — не враг. Это холст, на котором ты рисуешь свою реальность. Дыши глубже и пусть спокойствие ведет тебя."`;
      }

      calculateMelancholicProphecy(sensory) {
        return `Эхо улавливает смешанные сигналы — дождь (${(sensory.smell.rain * 100).toFixed(0)}%), шёпот (${(sensory.sound.whisper * 100).toFixed(0)}%), красные отблески (${(sensory.visual.red * 100).toFixed(0)}%). "Мир находится в переходе. То, что было, уже не вернётся. То, что будет, ещё не оформилось. Ты — мост между мирами, несущий свет воспоминаний."`;
      }
    }

    // Initialize Sensory Echo AI instance
    const sensoryEchoAI = new SensoryEchoAI();
  </script>

  <!-- Sensory Echo React App (Rewritten without JSX using React.createElement for no-Babel compatibility) -->
  <script>
    const { useState, useEffect } = React;
    const { Brain, Sparkles, Wind, Eye, Volume2 } = lucide;

    // Main SensoryEcho Component
    const SensoryEcho = () => {
      const [sensoryInput, setSensoryInput] = useState({
        smell: { rose: 0.5, rain: 0.3, fear: 0.1 },
        sound: { laughter: 0.5, silence: 0.3, whisper: 0.2 },
        visual: { blue: 0.5, red: 0.3, gold: 0.2 }
      });
      
      const [userInput, setUserInput] = useState('');
      const [prophecy, setProphecy] = useState('');
      const [emotionalState, setEmotionalState] = useState('neutral');
      const [particles, setParticles] = useState([]);

      // Generate particles for visual effects
      const generateParticles = () => {
        return Array.from({ length: 20 }, (_, i) => ({
          id: i,
          x: Math.random() * 100,
          y: Math.random() * 100,
          delay: Math.random() * 2,
          duration: 3 + Math.random() * 2
        }));
      };

      useEffect(() => {
        setParticles(generateParticles());
      }, [emotionalState]);

      // Handle analysis on button click
      const handleAnalyze = () => {
        const result = sensoryEchoAI.analyzeInput(userInput, sensoryInput);
        setProphecy(result.prophecyText);
        setEmotionalState(result.emotion);
        setParticles(generateParticles());
      };

      // Update sensory input values
      const updateSensory = (category, type, value) => {
        setSensoryInput(prev => ({
          ...prev,
          [category]: { ...prev[category], [type]: value }
        }));
      };

      // Emotion-based background gradients
      const emotionColors = {
        neutral: 'from-gray-600 to-gray-800',
        joyful: 'from-yellow-500 to-pink-500',
        anxious: 'from-red-600 to-purple-900',
        serene: 'from-blue-400 to-cyan-300',
        melancholic: 'from-indigo-600 to-purple-800'
      };

      // Create particle elements
      const particleElements = particles.map(p => 
        React.createElement('div', {
          key: p.id,
          className: 'echo-particle',
          style: {
            left: `${p.x}%`,
            top: `${p.y}%`,
            animationDelay: `${p.delay}s`,
            animationDuration: `${p.duration}s`
          }
        })
      );

      // Header section
      const header = React.createElement('div', { className: 'text-center mb-6' },
        React.createElement('div', { className: 'flex items-center justify-center gap-2 mb-2' },
          React.createElement(Brain, { className: 'w-8 h-8 text-white animate-pulse' }),
          React.createElement('h3', { className: 'text-2xl font-bold text-white' }, 'Эхо'),
          React.createElement(Sparkles, { className: 'w-8 h-8 text-white animate-pulse' })
        ),
        React.createElement('p', { className: 'text-white text-sm opacity-90' }, 'Сенсорный Пророк')
      );

      // Sensory input sections (using a helper function for reusability)
      const createSensorySection = (category, title, Icon) => {
        const entries = Object.entries(sensoryInput[category]);
        const sliders = entries.map(([type, value]) => 
          React.createElement('div', { key: type, className: 'flex items-center gap-2' },
            React.createElement('span', { className: 'text-white text-xs w-16' }, `${type}: ${(value * 100).toFixed(0)}%`),
            React.createElement('input', {
              type: 'range',
              min: 0,
              max: 1,
              step: 0.01,
              value: value,
              onChange: e => updateSensory(category, type, parseFloat(e.target.value)),
              className: 'flex-1 h-1 bg-white bg-opacity-20 rounded'
            })
          )
        );

        return React.createElement('div', null,
          React.createElement('div', { className: 'flex items-center gap-2 mb-2' },
            React.createElement(Icon, { className: 'w-4 h-4 text-white' }),
            React.createElement('span', { className: 'text-white font-medium capitalize' }, title)
          ),
          ...sliders
        );
      };

      const sensorySections = React.createElement('div', { className: 'bg-white bg-opacity-10 backdrop-blur-lg rounded-xl p-4 mb-4 border border-white border-opacity-20' },
        React.createElement('div', { className: 'space-y-4 text-sm' },
          createSensorySection('smell', 'Запахи', Wind),
          createSensorySection('sound', 'Звуки', Volume2),
          createSensorySection('visual', 'Цвета', Eye)
        )
      );

      // User input and button
      const userInputElement = React.createElement('input', {
        type: 'text',
        value: userInput,
        onChange: e => setUserInput(e.target.value),
        onKeyPress: e => { if (e.key === 'Enter') handleAnalyze(); },
        placeholder: 'Спроси Эхо...',
        className: 'w-full bg-white bg-opacity-20 text-white placeholder-white placeholder-opacity-60 rounded-lg px-3 py-2 mb-3 text-sm focus:outline-none focus:ring-2 focus:ring-white focus:ring-opacity-50'
      });

      const analyzeButton = React.createElement('button', {
        onClick: handleAnalyze,
        className: 'w-full bg-white bg-opacity-20 hover:bg-opacity-30 text-white font-semibold py-2 rounded-lg text-sm transition-all'
      }, 'Услышать Пророчество');

      // Prophecy display (conditional)
      const prophecyDisplay = prophecy ? React.createElement('div', { className: 'mt-4 bg-white bg-opacity-10 backdrop-blur-lg rounded-xl p-4 border border-white border-opacity-20 animate-pulse' },
        React.createElement('p', { className: 'text-white text-sm leading-relaxed italic' }, prophecy),
        React.createElement('p', { className: 'mt-2 text-xs text-white opacity-70 text-center' },
          'Эмоция: ',
          React.createElement('span', { className: 'font-semibold capitalize' }, emotionalState)
        )
      ) : null;

      // Main content wrapper
      const content = React.createElement('div', { className: 'relative z-10' },
        header,
        sensorySections,
        userInputElement,
        analyzeButton,
        prophecyDisplay
      );

      // Root element
      return React.createElement('div', {
        className: `min-h-[500px] bg-gradient-to-br ${emotionColors[emotionalState]} rounded-2xl p-6 relative overflow-hidden transition-all duration-1000`
      }, ...particleElements, content);
    };

    // Render the React App
    const root = ReactDOM.createRoot(document.getElementById('sensory-echo-root'));
    root.render(React.createElement(SensoryEcho));
  </script>
</body>
</html>
